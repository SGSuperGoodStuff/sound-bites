<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Bites - 16:9 Pro Editor</title>
    <!-- Dependencies -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body { 
            font-family: 'Inter', sans-serif; 
            overflow: hidden;
            background-color: #F8FAFC;
        }
        @media (max-width: 768px) {
            body { overflow: auto; }
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #e0e7ff;
            border-radius: 4px;
        }
        canvas { touch-action: none; border-radius: 1rem; }
        @keyframes countdown-pulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .animate-count {
            animation: countdown-pulse 0.5s ease-out forwards;
        }
        @keyframes record-pulse {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
            70% { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        .recording-active {
            animation: record-pulse 1.5s infinite;
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #312e81;
            border-radius: 10px;
        }
    </style>
</head>
<body class="bg-[#F8FAFC] bg-[radial-gradient(#E2E8F0_1px,transparent_1px)] [background-size:30px_30px]">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        const STEPS = [
            { id: 'upload', label: 'Photo' },
            { id: 'zoom', label: 'Frame' },
            { id: 'crop', label: 'Mouth' },
            { id: 'record', label: 'Sound' }
        ];

        const Icon = ({ name, size = 24, strokeWidth = 2, className = "", fill = "none" }) => {
            const icons = {
                Upload: <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/>,
                Mic: <><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v1a7 7 0 0 1-14 0v-1M12 19v3M8 22h8"/></>,
                Download: <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3"/>,
                RotateCcw: <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8M3 3v5h5"/>,
                Check: <path d="M20 6 9 17l-5-5"/>,
                Volume2: <><path d="M11 5 6 9H2v6h4l5 4V5Z"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 0 1 0 14.14"/></>,
                Trash2: <><path d="M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2M10 11v6M14 11v6"/></>,
                Undo2: <path d="M9 14 4 9l5-5M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/>,
                Camera: <><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></>,
                Plus: <path d="M12 5v14M5 12h14"/>,
                ArrowLeft: <path d="m12 19-7-7 7-7M5 12h14"/>,
                History: <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8M3 3v5h5"/>,
                VolumeX: <><path d="M11 5 6 9H2v6h4l5 4V5Z"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></>,
                RefreshCcw: <path d="M1 4v6h6M23 20v-6h-6M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15" />,
                Square: <rect x="5" y="5" width="14" height="14" rx="2" />,
                Play: <polygon points="6 3 20 12 6 21 6 3"/>
            };
            return (
                <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill={fill} stroke="currentColor" strokeWidth={strokeWidth} strokeLinecap="round" strokeLinejoin="round" className={className}>
                    {icons[name] || <circle cx="12" cy="12" r="10" />}
                </svg>
            );
        };

        const App = () => {
            const [originalImage, setOriginalImage] = useState(null);
            const [displayImage, setDisplayImage] = useState(null); 
            const [stage, setStage] = useState('init'); 
            const [isRecording, setIsRecording] = useState(false);
            const [mouthPoints, setMouthPoints] = useState([]); 
            const [isMouthClosed, setIsMouthClosed] = useState(false);
            const [mouthSensitivity, setMouthSensitivity] = useState(80); 
            const [videoUrl, setVideoUrl] = useState(null);
            const [recordedMimeType, setRecordedMimeType] = useState('');
            const [audioSourceType, setAudioSourceType] = useState('mic'); 
            const [uploadedAudioFile, setUploadedAudioFile] = useState(null);
            const [zoomRect, setZoomRect] = useState({ x: 0, y: 0, width: 300, height: 300 });
            const [interactionMode, setInteractionMode] = useState(null); 
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [countdown, setCountdown] = useState(3);
            const [isCountingDown, setIsCountingDown] = useState(false);
            const [fileName, setFileName] = useState('my-sound-bite');
            const [micPermissionStatus, setMicPermissionStatus] = useState('unknown');
            const [currentVolumeDisplay, setCurrentVolumeDisplay] = useState(0);
            const [sessionSegments, setSessionSegments] = useState(0);
            const [isFilePlaying, setIsFilePlaying] = useState(false);

            const canvasRef = useRef(null);
            const zoomCanvasRef = useRef(null);
            const audioContextRef = useRef(null);
            const analyserRef = useRef(null);
            const mediaRecorderRef = useRef(null);
            const streamRef = useRef(null);
            const animationFrameRef = useRef(null);
            const chunksRef = useRef([]);
            const masterChunksRef = useRef([]); 
            const audioPlayerRef = useRef(null); 
            
            const smoothedVolumeRef = useRef(0);
            const sensitivityRef = useRef(80);
            const pointsRef = useRef([]);
            const isClosedRef = useRef(false);
            const displayImageRef = useRef(null);
            const stageRef = useRef('init');

            useEffect(() => { sensitivityRef.current = mouthSensitivity; }, [mouthSensitivity]);
            useEffect(() => { pointsRef.current = mouthPoints; }, [mouthPoints]);
            useEffect(() => { isClosedRef.current = isMouthClosed; }, [isMouthClosed]);
            useEffect(() => { displayImageRef.current = displayImage; }, [displayImage]);
            useEffect(() => { stageRef.current = stage; }, [stage]);

            const activeStepIndex = (stage === 'init' || stage === 'upload') ? 0 : (stage === 'preview' ? 4 : STEPS.findIndex(s => s.id === stage));
            const fileExtension = recordedMimeType.includes('mp4') ? 'mp4' : 'webm';

            const setupAudioContext = useCallback(() => {
                if (!audioContextRef.current) {
                    audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                return audioContextRef.current;
            }, []);

            const getPreciseCoords = (e, canvas, sourceW, sourceH) => {
                if (!canvas) return { x: 0, y: 0 };
                const rect = canvas.getBoundingClientRect();
                const containerRatio = rect.width / rect.height;
                const imageRatio = sourceW / sourceH;
                let scale, xOffset = 0, yOffset = 0;
                if (imageRatio > containerRatio) {
                    scale = sourceW / rect.width;
                    yOffset = (rect.height - (sourceH / scale)) / 2;
                } else {
                    scale = sourceH / rect.height;
                    xOffset = (rect.width - (sourceW / scale)) / 2;
                }
                return { x: (e.clientX - rect.left - xOffset) * scale, y: (e.clientY - rect.top - yOffset) * scale };
            };

            const drawCanvas = useCallback((currentVol = 0) => {
                const canvas = canvasRef.current;
                const img = displayImageRef.current;
                if (!canvas || !img) return;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);

                const pts = pointsRef.current;
                const isClosed = isClosedRef.current;
                const currentStage = stageRef.current;

                if (isClosed && pts.length > 2) {
                    const shift = (currentVol / 180) * sensitivityRef.current; 
                    ctx.fillStyle = '#1a0505'; 
                    ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
                    pts.forEach(p => ctx.lineTo(p.x, p.y)); 
                    ctx.closePath(); ctx.fill();
                    ctx.save();
                    ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y + shift);
                    pts.forEach(p => ctx.lineTo(p.x, p.y + shift)); 
                    ctx.closePath(); ctx.clip();
                    ctx.drawImage(img, 0, shift);
                    ctx.restore();
                }

                if (currentStage === 'crop' && pts.length > 0) {
                    ctx.strokeStyle = isClosed ? '#4ADE80' : '#F472B6'; 
                    ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
                    pts.forEach(p => ctx.lineTo(p.x, p.y));
                    if (isClosed) ctx.closePath();
                    ctx.stroke();
                    pts.forEach((p, i) => {
                        ctx.fillStyle = (pts.length >= 3 && i === 0 && !isClosed) ? '#FACC15' : '#FFF'; 
                        ctx.strokeStyle = isClosed ? '#4ADE80' : '#F472B6';
                        ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.arc(p.x, p.y, i === 0 ? 10 : 6, 0, Math.PI * 2);
                        ctx.fill(); ctx.stroke();
                    });
                }
            }, []);

            useEffect(() => { drawCanvas(0); }, [displayImage, mouthPoints, isMouthClosed, stage, drawCanvas]);

            const setupAnalyser = useCallback((source) => {
                const ctx = setupAudioContext();
                analyserRef.current = ctx.createAnalyser();
                analyserRef.current.fftSize = 512; 
                analyserRef.current.smoothingTimeConstant = 0.4; 
                source.connect(analyserRef.current);
                const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);
                const updateVolume = () => {
                    if (!analyserRef.current) return;
                    analyserRef.current.getByteFrequencyData(dataArray);
                    let sum = 0, count = 0;
                    for (let i = 2; i < 40; i++) { sum += dataArray[i]; count++; }
                    const rawAverage = sum / count;
                    const gate = 25; 
                    const normalized = Math.max(0, rawAverage - gate) / (255 - gate);
                    const curved = Math.pow(normalized, 1.25) * 255; 
                    const smoothingFactor = curved > smoothedVolumeRef.current ? 0.7 : 0.22;
                    smoothedVolumeRef.current = smoothedVolumeRef.current + (curved - smoothedVolumeRef.current) * smoothingFactor;
                    if (Math.random() > 0.8) setCurrentVolumeDisplay(smoothedVolumeRef.current);
                    drawCanvas(smoothedVolumeRef.current);
                    animationFrameRef.current = requestAnimationFrame(updateVolume);
                };
                updateVolume();
            }, [setupAudioContext, drawCanvas]);

            const stopAllAudio = () => {
                if (audioPlayerRef.current) {
                    audioPlayerRef.current.pause();
                    audioPlayerRef.current = null;
                }
                if (streamRef.current) {
                    streamRef.current.getTracks().forEach(t => t.stop());
                    streamRef.current = null;
                }
                cancelAnimationFrame(animationFrameRef.current);
                analyserRef.current = null;
                setIsFilePlaying(false);
            };

            const startVisualizerPreview = useCallback(async () => {
                try {
                    stopAllAudio();
                    const ctx = setupAudioContext();
                    if (ctx.state === 'suspended') await ctx.resume();

                    if (audioSourceType === 'mic') {
                        streamRef.current = await navigator.mediaDevices.getUserMedia({ audio: true });
                        setupAnalyser(ctx.createMediaStreamSource(streamRef.current));
                    } else if (audioSourceType === 'file' && uploadedAudioFile) {
                        const audio = new Audio(URL.createObjectURL(uploadedAudioFile));
                        audioPlayerRef.current = audio;
                        const source = ctx.createMediaElementSource(audio);
                        source.connect(ctx.destination);
                        setupAnalyser(source);
                        audio.onended = () => setIsFilePlaying(false);
                        audio.play();
                        setIsFilePlaying(true);
                    }
                } catch (e) { console.error("Preview fail", e); }
            }, [audioSourceType, uploadedAudioFile, setupAudioContext, setupAnalyser]);

            const requestMicPermission = async () => {
                try {
                    const ctx = setupAudioContext();
                    if (ctx.state === 'suspended') await ctx.resume();
                    const testStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    testStream.getTracks().forEach(track => track.stop());
                    setMicPermissionStatus('granted');
                } catch (err) {
                    setMicPermissionStatus('denied');
                }
                setStage('upload');
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            setOriginalImage(img);
                            setStage('zoom');
                            const initialSize = Math.min(img.width, img.height) * 0.6;
                            setZoomRect({ x: (img.width - initialSize) / 2, y: (img.height - initialSize) / 2, width: initialSize, height: initialSize });
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
                e.target.value = '';
            };

            const handleAudioUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    setUploadedAudioFile(file);
                    if (streamRef.current) {
                        streamRef.current.getTracks().forEach(t => t.stop());
                        streamRef.current = null;
                    }
                }
                e.target.value = '';
            };

            useEffect(() => {
                if (!interactionMode || stage !== 'zoom' || !originalImage) return;
                const handleGlobalMove = (e) => {
                    const coords = getPreciseCoords(e, zoomCanvasRef.current, originalImage.width, originalImage.height);
                    if (interactionMode === 'drag') {
                        setZoomRect(prev => ({
                            ...prev,
                            x: Math.max(0, Math.min(coords.x - dragOffset.x, originalImage.width - prev.width)),
                            y: Math.max(0, Math.min(coords.y - dragOffset.y, originalImage.height - prev.height))
                        }));
                    } else if (interactionMode === 'resize') {
                        setZoomRect(prev => ({
                            ...prev,
                            width: Math.max(50, Math.min(coords.x - prev.x, originalImage.width - prev.x)),
                            height: Math.max(50, Math.min(coords.y - prev.y, originalImage.height - prev.y))
                        }));
                    }
                };
                const handleGlobalUp = () => setInteractionMode(null);
                window.addEventListener('mousemove', handleGlobalMove);
                window.addEventListener('mouseup', handleGlobalUp);
                return () => { window.removeEventListener('mousemove', handleGlobalMove); window.removeEventListener('mouseup', handleGlobalUp); };
            }, [interactionMode, dragOffset, originalImage, stage]);

            const handleZoomDown = (e) => {
                if (!zoomCanvasRef.current || !originalImage) return;
                const coords = getPreciseCoords(e, zoomCanvasRef.current, originalImage.width, originalImage.height);
                const rect = zoomCanvasRef.current.getBoundingClientRect();
                const handleBuffer = 30 * (originalImage.width / rect.width);
                if (coords.x > zoomRect.x + zoomRect.width - handleBuffer && 
                    coords.x < zoomRect.x + zoomRect.width + handleBuffer &&
                    coords.y > zoomRect.y + zoomRect.height - handleBuffer &&
                    coords.y < zoomRect.y + zoomRect.height + handleBuffer) {
                    setInteractionMode('resize');
                } else if (coords.x > zoomRect.x && coords.x < zoomRect.x + zoomRect.width && coords.y > zoomRect.y && coords.y < zoomRect.y + zoomRect.height) {
                    setInteractionMode('drag');
                    setDragOffset({ x: coords.x - zoomRect.x, y: coords.y - zoomRect.y });
                }
            };

            useEffect(() => {
                if (stage === 'zoom' && originalImage && zoomCanvasRef.current) {
                    const ctx = zoomCanvasRef.current.getContext('2d');
                    ctx.clearRect(0, 0, zoomCanvasRef.current.width, zoomCanvasRef.current.height);
                    ctx.drawImage(originalImage, 0, 0);
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(0, 0, originalImage.width, zoomRect.y);
                    ctx.fillRect(0, zoomRect.y + zoomRect.height, originalImage.width, originalImage.height - (zoomRect.y + zoomRect.height));
                    ctx.fillRect(0, zoomRect.y, zoomRect.x, zoomRect.height);
                    ctx.fillRect(zoomRect.x + zoomRect.width, zoomRect.y, originalImage.width - (zoomRect.x + zoomRect.width), zoomRect.height);
                    ctx.strokeStyle = '#6366F1'; ctx.lineWidth = originalImage.width / 150;
                    ctx.strokeRect(zoomRect.x, zoomRect.y, zoomRect.width, zoomRect.height);
                    const hSize = Math.max(10, originalImage.width / 50);
                    ctx.fillStyle = '#6366F1'; ctx.beginPath();
                    ctx.arc(zoomRect.x + zoomRect.width, zoomRect.y + zoomRect.height, hSize, 0, Math.PI * 2);
                    ctx.fill(); ctx.strokeStyle = 'white'; ctx.lineWidth = hSize / 4; ctx.stroke();
                }
            }, [stage, originalImage, zoomRect]);

            const applyZoom = () => {
                const tempCanvas = document.createElement('canvas');
                const maxDim = 1000;
                let targetW = maxDim, targetH = (zoomRect.height / zoomRect.width) * maxDim;
                tempCanvas.width = targetW; tempCanvas.height = targetH;
                const tCtx = tempCanvas.getContext('2d');
                tCtx.drawImage(originalImage, zoomRect.x, zoomRect.y, zoomRect.width, zoomRect.height, 0, 0, targetW, targetH);
                const croppedImg = new Image();
                croppedImg.onload = () => { setDisplayImage(croppedImg); setMouthPoints([]); setIsMouthClosed(false); setStage('crop'); };
                croppedImg.src = tempCanvas.toDataURL();
            };

            const handleMouthClick = (e) => {
                if (stage !== 'crop' || isMouthClosed) return;
                const coords = getPreciseCoords(e, canvasRef.current, displayImage.width, displayImage.height);
                if (mouthPoints.length >= 3) {
                    const dist = Math.sqrt(Math.pow(coords.x - mouthPoints[0].x, 2) + Math.pow(coords.y - mouthPoints[0].y, 2));
                    const rect = canvasRef.current.getBoundingClientRect();
                    const hitRadius = 12 * (displayImage.width / rect.width);
                    if (dist < hitRadius) { 
                        setIsMouthClosed(true); 
                        if (audioSourceType === 'mic') startVisualizerPreview();
                        return; 
                    }
                }
                if (mouthPoints.length < 20) setMouthPoints(prev => [...prev, coords]);
            };

            const handleStartClick = async () => {
                const ctx = setupAudioContext();
                if (ctx.state === 'suspended') await ctx.resume();
                setCountdown(3);
                setIsCountingDown(true);
            };

            useEffect(() => {
                let timer;
                if (isCountingDown) {
                    if (countdown > 0) {
                        timer = setTimeout(() => setCountdown(prev => prev - 1), 1000);
                    } else {
                        setIsCountingDown(false);
                        startRecording();
                    }
                }
                return () => timer && clearTimeout(timer);
            }, [isCountingDown, countdown]);

            const startRecording = async () => {
                try {
                    const ctx = setupAudioContext();
                    const canvasStream = canvasRef.current.captureStream(30);
                    let audioTrack;

                    if (audioSourceType === 'mic') {
                        if (!streamRef.current) streamRef.current = await navigator.mediaDevices.getUserMedia({ audio: true });
                        audioTrack = streamRef.current.getAudioTracks()[0];
                        setupAnalyser(ctx.createMediaStreamSource(streamRef.current));
                    } else {
                        const audio = new Audio(URL.createObjectURL(uploadedAudioFile));
                        audioPlayerRef.current = audio;
                        const source = ctx.createMediaElementSource(audio);
                        const dest = ctx.createMediaStreamDestination();
                        
                        source.connect(ctx.destination);
                        source.connect(dest);
                        setupAnalyser(source);
                        
                        audioTrack = dest.stream.getAudioTracks()[0];
                        audio.onended = () => finishRecording();
                        audio.play();
                    }

                    const combined = new MediaStream([...canvasStream.getVideoTracks(), audioTrack]);
                    const mimeType = MediaRecorder.isTypeSupported('video/mp4;codecs=avc1,mp4a.40.2') ? 'video/mp4;codecs=avc1,mp4a.40.2' : 'video/webm';
                    setRecordedMimeType(mimeType);

                    mediaRecorderRef.current = new MediaRecorder(combined, { mimeType, videoBitsPerSecond: 2500000 });
                    chunksRef.current = [];
                    mediaRecorderRef.current.ondataavailable = (e) => {
                        if (e.data && e.data.size > 0) {
                            chunksRef.current.push(e.data);
                        }
                    };
                    mediaRecorderRef.current.onstop = () => {
                        masterChunksRef.current = [...masterChunksRef.current, ...chunksRef.current];
                        const blob = new Blob(masterChunksRef.current, { type: mimeType });
                        setVideoUrl(URL.createObjectURL(blob));
                        setIsRecording(false);
                        setStage('preview');
                    };
                    mediaRecorderRef.current.start();
                    setIsRecording(true);
                } catch (err) { console.error("Rec Error:", err); }
            };

            const finishRecording = () => {
                if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') mediaRecorderRef.current.stop();
                stopAllAudio();
            };

            const reset = () => {
                stopAllAudio();
                setOriginalImage(null); setDisplayImage(null); setStage('upload'); setVideoUrl(null);
                setMouthPoints([]); setIsMouthClosed(false); masterChunksRef.current = []; setSessionSegments(0);
                if (audioContextRef.current) audioContextRef.current.close().then(() => audioContextRef.current = null);
            };

            const restartSound = () => {
                stopAllAudio();
                setVideoUrl(null);
                masterChunksRef.current = [];
                setStage('record');
            };

            return (
                <div className="h-screen flex flex-col bg-slate-50">
                    <header className="bg-white border-b flex items-center justify-between px-6 py-3 shadow-sm z-20">
                        <div className="flex items-center gap-3">
                            <div className="bg-indigo-600 p-1.5 rounded-lg text-white">
                                <Icon name="Volume2" size={20} strokeWidth={3} />
                            </div>
                            <h1 className="text-xl font-black tracking-tight italic text-indigo-900 uppercase">SOUND BITES</h1>
                        </div>
                        <div className="hidden md:flex items-center gap-8">
                            {STEPS.map((step, idx) => (
                                <div key={step.id} className="flex items-center gap-2">
                                    <div className={`w-6 h-6 rounded-full flex items-center justify-center text-[10px] font-black ${idx <= activeStepIndex ? 'bg-indigo-600 text-white' : 'bg-slate-100 text-slate-400'}`}>
                                        {idx < activeStepIndex ? <Icon name="Check" size={12} strokeWidth={4} /> : idx + 1}
                                    </div>
                                    <span className={`text-[11px] font-bold uppercase tracking-wider ${idx <= activeStepIndex ? 'text-indigo-900' : 'text-slate-400'}`}>
                                        {step.label}
                                    </span>
                                    {idx < STEPS.length - 1 && <div className="w-4 h-0.5 bg-slate-200" />}
                                </div>
                            ))}
                        </div>
                        <div className="flex items-center gap-4">
                            {stage !== 'init' && stage !== 'upload' && <button onClick={reset} className="text-[10px] font-bold text-slate-400 hover:text-indigo-600 uppercase tracking-widest transition-colors">Start Over</button>}
                            <div className="text-[10px] px-3 py-1 bg-indigo-50 text-indigo-600 rounded-full font-bold uppercase tracking-widest border border-indigo-100 shadow-sm">STUDIO</div>
                        </div>
                    </header>

                    <main className="flex-1 flex overflow-hidden p-6 gap-6 max-w-screen-2xl mx-auto w-full">
                        {stage === 'init' ? (
                            <div className="w-full h-full flex items-center justify-center">
                                <div className="max-w-md w-full bg-white rounded-[2.5rem] shadow-2xl p-10 flex flex-col items-center text-center border-4 border-indigo-50">
                                    <div className="w-24 h-24 flex items-center justify-center mb-8 animate-bounce text-7xl select-none">
                                        ðŸ¦Ÿ
                                    </div>
                                    <h2 className="text-3xl font-black text-indigo-900 mb-4 tracking-tight uppercase">Itching to Create?</h2>
                                    <p className="text-slate-500 font-medium mb-10 leading-relaxed text-sm">Allow microphone access to get this project off the ground. We won't bite!</p>
                                    <button onClick={requestMicPermission} className="w-full py-5 bg-indigo-600 text-white rounded-2xl font-black text-lg shadow-lg hover:bg-indigo-500 transition-all active:scale-95 uppercase">Initialize Studio</button>
                                </div>
                            </div>
                        ) : stage === 'upload' ? (
                            <div className="w-full h-full flex items-center justify-center">
                                <label htmlFor="image-upload" className="w-full max-w-2xl aspect-video bg-white rounded-[2rem] border-4 border-dashed border-indigo-100 flex flex-col items-center justify-center cursor-pointer hover:border-indigo-400 hover:bg-indigo-50/30 transition-all shadow-xl group">
                                    <input id="image-upload" type="file" className="hidden" accept="image/*" onChange={handleImageUpload} />
                                    <div className="w-20 h-20 bg-indigo-600 rounded-2xl flex items-center justify-center text-white mb-6 group-hover:scale-110 transition-transform shadow-lg"><Icon name="Camera" size={32} /></div>
                                    <h3 className="text-2xl font-black text-indigo-900 tracking-tight">Add a Portrait</h3>
                                    <p className="text-slate-400 mt-2 font-medium italic">Select a clear photo for high-quality animation.</p>
                                </label>
                            </div>
                        ) : (
                            <div className="flex flex-1 w-full gap-6 overflow-hidden">
                                <div className="flex-[3] bg-white rounded-[2rem] shadow-xl border-4 border-white flex flex-col overflow-hidden relative">
                                    <div className="flex-1 bg-slate-100 flex items-center justify-center relative overflow-hidden">
                                        {stage === 'zoom' && <canvas ref={zoomCanvasRef} width={originalImage?.width} height={originalImage?.height} onMouseDown={handleZoomDown} className="max-w-full max-h-full object-contain cursor-move" />}
                                        {(stage === 'crop' || stage === 'record') && (
                                            <div className="relative w-full h-full flex items-center justify-center">
                                                <canvas ref={canvasRef} width={displayImage?.width} height={displayImage?.height} onClick={handleMouthClick} className={`max-w-full max-h-full object-contain ${stage === 'crop' && !isMouthClosed ? 'cursor-crosshair' : ''}`} />
                                                {isCountingDown && (
                                                    <div className="absolute inset-0 z-50 flex items-center justify-center bg-indigo-900/40 backdrop-blur-[2px]">
                                                        <div className="text-9xl font-black text-white animate-count">{countdown}</div>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                        {stage === 'preview' && (
                                            <div className="w-full h-full flex items-center justify-center bg-black">
                                                {videoUrl && <video key={videoUrl} src={videoUrl} controls autoPlay className="max-w-full max-h-full" />}
                                            </div>
                                        )}
                                    </div>
                                    <div className="bg-white px-6 py-2 border-t flex justify-between items-center text-[10px] font-bold text-slate-400 uppercase tracking-widest">
                                        <div className="flex items-center gap-2">
                                            <div className={`w-2 h-2 rounded-full ${isRecording ? 'bg-red-500 animate-pulse' : 'bg-green-400'}`} />
                                            {stage.toUpperCase()} MODE
                                        </div>
                                        <div className="flex items-center gap-4">
                                            <div className="flex items-center gap-1">
                                                <div className="w-16 h-2 bg-slate-100 rounded-full overflow-hidden flex">
                                                    <div className="h-full bg-indigo-500 transition-all duration-75" style={{ width: `${Math.min(100, currentVolumeDisplay)}%` }} />
                                                </div>
                                                <span>SIGNAL</span>
                                            </div>
                                            <span>PRECISION ENGINE</span>
                                        </div>
                                    </div>
                                </div>

                                <div className="flex-1 bg-indigo-900 rounded-[2rem] shadow-xl p-8 flex flex-col justify-between text-white overflow-y-auto custom-scrollbar">
                                    <div>
                                        <h2 className="text-2xl font-black italic mb-2 tracking-tight text-white uppercase leading-tight">
                                            {stage === 'zoom' && "Composition"}
                                            {stage === 'crop' && "Mouth Marker"}
                                            {stage === 'record' && "Live Recording"}
                                            {stage === 'preview' && "Review Sound Bite"}
                                        </h2>
                                        <p className="text-indigo-200 text-xs font-medium mb-8 leading-relaxed italic opacity-80 uppercase tracking-widest">
                                            {stage === 'zoom' && "Frame the face for high-res animation."}
                                            {stage === 'crop' && "Draw the mouth (Up to 20 pts)."}
                                            {stage === 'record' && "Start recording after the countdown."}
                                            {stage === 'preview' && "Check your sound bite below."}
                                        </p>

                                        <div className="space-y-6">
                                            {stage === 'zoom' && (
                                                <button onClick={applyZoom} className="w-full py-4 bg-white text-indigo-600 rounded-2xl font-black shadow-lg hover:bg-indigo-50 transition-colors flex items-center justify-center gap-2 uppercase text-xs">Confirm Frame <Icon name="Check" size={18} /></button>
                                            )}

                                            {stage === 'crop' && (
                                                <>
                                                    <div className="bg-indigo-800/50 p-4 rounded-2xl border border-indigo-700">
                                                        <div className="flex justify-between text-[10px] font-black uppercase mb-3 text-indigo-300"><span>Progress</span><span>{mouthPoints.length}/20</span></div>
                                                        <div className="flex gap-1 h-1.5 overflow-hidden">
                                                            {[...Array(20)].map((_, i) => <div key={i} className={`flex-1 rounded-full transition-all ${i < mouthPoints.length ? 'bg-indigo-400' : 'bg-indigo-950'}`} />)}
                                                        </div>
                                                    </div>
                                                    
                                                    {isMouthClosed && (
                                                        <div className="space-y-3 bg-indigo-950/40 p-4 rounded-xl border border-indigo-700 animate-in fade-in duration-500">
                                                            <div className="flex justify-between text-[10px] font-black uppercase text-indigo-400 tracking-widest"><span>Movement Test</span><span>{mouthSensitivity}%</span></div>
                                                            <input type="range" min="10" max="150" value={mouthSensitivity} onChange={(e) => setMouthSensitivity(Number(e.target.value))} className="w-full" />
                                                            {audioSourceType === 'file' && uploadedAudioFile && (
                                                                <button onClick={startVisualizerPreview} className="w-full py-2 bg-indigo-600 text-white rounded-lg text-[9px] font-black uppercase tracking-widest flex items-center justify-center gap-2 transition-all hover:bg-indigo-500">
                                                                    {isFilePlaying ? <Icon name="Volume2" size={12} /> : <Icon name="Play" size={12} />}
                                                                    {isFilePlaying ? "PLAYING TEST..." : "TEST AUDIO MOVEMENT"}
                                                                </button>
                                                            )}
                                                        </div>
                                                    )}

                                                    <button onClick={() => { setMouthPoints(p => p.slice(0, -1)); setIsMouthClosed(false); }} className="w-full py-3 bg-indigo-800 rounded-xl text-[10px] font-bold hover:bg-indigo-700 flex items-center justify-center gap-2 transition-colors uppercase tracking-widest"><Icon name="Undo2" size={14} /> Undo Point</button>
                                                    <button disabled={!isMouthClosed} onClick={() => setStage('record')} className={`w-full py-5 rounded-2xl font-black transition-all flex items-center justify-center gap-3 uppercase text-xs ${isMouthClosed ? 'bg-white text-indigo-600 shadow-xl scale-[1.02]' : 'bg-indigo-800 text-indigo-400 opacity-50 cursor-not-allowed'}`}>Go To Record <Icon name="ArrowLeft" size={18} className="rotate-180" /></button>
                                                </>
                                            )}

                                            {stage === 'record' && (
                                                <div className="space-y-6">
                                                    <div className="flex bg-indigo-950 p-1 rounded-xl">
                                                        <button onClick={() => { stopAllAudio(); setAudioSourceType('mic'); }} className={`flex-1 py-2 rounded-lg text-[10px] font-bold transition-all ${audioSourceType === 'mic' ? 'bg-indigo-600 text-white shadow' : 'text-indigo-400'}`}>MIC</button>
                                                        <button onClick={() => { stopAllAudio(); setAudioSourceType('file'); }} className={`flex-1 py-2 rounded-lg text-[10px] font-bold transition-all ${audioSourceType === 'file' ? 'bg-indigo-600 text-white shadow' : 'text-indigo-400'}`}>FILE</button>
                                                    </div>
                                                    {audioSourceType === 'file' && (
                                                        <label htmlFor="audio-upload" className="w-full flex items-center justify-center gap-3 p-4 border-2 border-dashed border-indigo-700 rounded-xl cursor-pointer hover:bg-indigo-950/50">
                                                            <input id="audio-upload" type="file" className="hidden" accept="audio/*" onChange={handleAudioUpload} />
                                                            <Icon name={uploadedAudioFile ? "Check" : "Upload"} size={16} />
                                                            <span className="text-[10px] font-bold truncate tracking-tight">{uploadedAudioFile ? uploadedAudioFile.name : 'Select Audio File'}</span>
                                                        </label>
                                                    )}
                                                    <div className="space-y-3">
                                                        <div className="flex justify-between text-[10px] font-black uppercase text-indigo-300"><span>Mouth Power</span><span>{mouthSensitivity}%</span></div>
                                                        <input type="range" min="10" max="150" value={mouthSensitivity} onChange={(e) => setMouthSensitivity(Number(e.target.value))} className="w-full" />
                                                    </div>
                                                    <div className="flex justify-center pt-4">
                                                        {!isRecording ? (
                                                            <button 
                                                                disabled={(micPermissionStatus === 'denied' && audioSourceType === 'mic') || (audioSourceType === 'file' && !uploadedAudioFile)} 
                                                                onClick={handleStartClick} 
                                                                className={`w-28 h-28 rounded-full flex items-center justify-center shadow-xl transition-all ${((micPermissionStatus === 'denied' && audioSourceType === 'mic') || (audioSourceType === 'file' && !uploadedAudioFile)) ? 'bg-slate-700 opacity-50' : 'bg-red-500 hover:bg-red-600 hover:scale-105 active:scale-95'}`}
                                                            >
                                                                <Icon 
                                                                    name={audioSourceType === 'mic' ? "Mic" : "Play"} 
                                                                    size={44} 
                                                                    strokeWidth={2.5} 
                                                                    className={`text-white ${audioSourceType === 'file' ? 'pl-2' : ''}`} 
                                                                    fill={audioSourceType === 'file' ? 'currentColor' : 'none'}
                                                                />
                                                            </button>
                                                        ) : (
                                                            <button 
                                                                onClick={finishRecording} 
                                                                className="w-28 h-28 bg-white rounded-full flex items-center justify-center shadow-xl border-4 border-red-500 transition-all hover:scale-105 active:scale-95 recording-active"
                                                            >
                                                                <Icon name="Square" size={36} className="text-red-500 fill-red-500" strokeWidth={0} />
                                                            </button>
                                                        )}
                                                    </div>
                                                </div>
                                            )}

                                            {stage === 'preview' && (
                                                <div className="space-y-4">
                                                    <div className="bg-indigo-950 p-5 rounded-2xl border border-indigo-700 mb-2">
                                                        <label className="text-[10px] font-black uppercase text-indigo-400 mb-2 block tracking-widest">Sound Bite Name</label>
                                                        <div className="flex items-center bg-indigo-900 p-3 rounded-xl focus-within:ring-2 ring-indigo-500 transition-all">
                                                            <input type="text" value={fileName} onChange={(e) => setFileName(e.target.value)} className="bg-transparent border-none outline-none text-white font-bold w-full text-sm" />
                                                            <span className="text-[10px] text-indigo-400 font-black ml-2 uppercase">.{fileExtension}</span>
                                                        </div>
                                                    </div>

                                                    <div className="grid grid-cols-1 gap-3">
                                                        <button onClick={restartSound} className="w-full py-5 bg-indigo-600 text-white rounded-2xl font-black text-xs flex items-center justify-center gap-3 hover:bg-indigo-500 shadow-lg active:scale-95 transition-all uppercase tracking-wider">
                                                            <Icon name="RefreshCcw" size={20} strokeWidth={3} /> Restart Sound
                                                        </button>
                                                        
                                                        <a href={videoUrl} download={`${fileName || 'my-sound-bite'}.${fileExtension}`} className="w-full py-5 bg-green-500 text-white rounded-2xl font-black text-xs flex items-center justify-center gap-3 hover:bg-green-400 transition-all shadow-lg active:scale-95 uppercase tracking-wider">
                                                            <Icon name="Download" size={20} strokeWidth={3} /> Download Sound Bite
                                                        </a>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                    </main>

                    <footer className="px-10 py-3 bg-white border-t flex items-center justify-between text-[10px] font-bold text-slate-400 uppercase tracking-widest">
                        <div className="flex items-center gap-4">
                            <span>SOUND BITES ðŸ¦Ÿ â€¢ SINGLE TAKE STUDIO</span>
                        </div>
                        <div className="flex gap-4">
                            <span className="flex items-center gap-1"><Icon name={micPermissionStatus === 'granted' ? "Check" : "VolumeX"} size={10} strokeWidth={4} className={micPermissionStatus === 'granted' ? "text-green-500" : "text-red-400"} /> MIC</span>
                            <div className="w-px h-3 bg-slate-200" />
                            <span>AAC ENGINE</span>
                        </div>
                    </footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>